一、前台接收后台返回数据：
   {
     "msg":"",
     "stateCod":"",
     "total":2,
     "rows":[{},{},{}]
   }
   msg:返回提示信息
   stateCod:返回自定义状态代码
   total:查询数据的总行数
   rows:本页显示记录,或者错误信息
二、前台向后台批量提交数据：
   {
     "i":[{},{},{}],
     "d":[id,id,id,id],
     "u":[{
        "old_data":{},
        "new_data:{},
          },{
        "old_data":{},
        "new_data:{}
          },......]
   }
   i:新增加记录数组
   d:要删除记录id数组
   u:修改对象记录数组,old_data原始数据，new_data修改后数据
三、前台向后台提交查询：
  {
     'page':1,
     'rows':10,
     'filter':'[{
        'cod':'client_name',
        'operatorTyp':'等于',
        'value':'值'
     }]',
     'sort':'[{
       'cod':'client_name',
       'order_typ':'升序'
     }]'
  }
  page:当前页数
  rows:每页显示记录数
  filter:过滤条件数组,cod-字段名
                    operatorTyp-过滤条件有等于、不等于、大于、大于等于、
                               小于、小于等于、包含、不包含、属于、不属于指定范围
                    value:参数值,多个值以','分隔

  sort:排序条件数组,cod-字段名
                  order_typ 排序方式 升序和将序
四、
    关于安全性的说明：
第一是防止前台插入新的语句。比如delete all；这样的,
第二就是要客户登陆。
第三就是要有log日志。

第1条，关键是把select ， update， delete 的参数屏蔽掉。还有引号，大于号什么的，safestring转换掉。
第2条，客户登录，用cookie保存５个小时。
第3条，log日志。

对于前台拼出来的功能性操作，不出现字段和内容是可以的。就是功能列出来以后，定义原子操作。

比如 1、客户。values作为参数。。前台传给后台
ins（‘客户’， json（插入客户数据））
del（‘客户’， json（'id'））
upd（‘客户’， json（'id', newvalue, oldvalue））   // 所有数据库字段都是非空。传递的数值用None来表示没变化，或者没有插入数值。

级联数据的操作方法如下：
op：update，
num: xx
【
ins{‘客户’， json（插入客户数据1）, subs: {num:xx, ins:（‘客户子表’， json‘客户数据’， subs（客户子表的子表。。。）））））
ins{‘客户’， json（插入客户数据2）, subs: {num:0 }
upd{‘客户’， json（更新客户数据3）, subs: {num:xx, upd:...}
】
返回：state： ok、faile，errortext：‘’，  affectrowsall：xx｛ ins：id，affectrows影响行数：xx， subs ｛affectrows：xx，  upd：id， del：id， ｝



前台自动生成，后台根据前台自动进行更新的方法：
  {
     'reqtype':'query' /  'update'（包括insert，udpate，delete）
     args: # query
     {
        'page':1,
        'rows':10,
        'cols':['colname1','colname2','colname3],
        'filter':'[{
            'cod':'client_name',
            'operatorTyp':'等于',
            'value':'值'
                    }]',
        'sort':'[{
            'cod':'client_name',
            'order_typ':'升序'
        }]'
     }
     args: update
---------------------------------------------------------------------
        'rows': [
            {
                'op': 'insert',
                'table': 'c_client',
                'cols': [{'col1':'value1', 'cold2':'value2', 'c3':'value3'....}],
                'uuid': 'xxxx',
                'id': -1,
                'subs': { rows: [递归] } //没有就空着
            },
-------------------------------------------------------------------------
            -- 返回  { state: 0 / -100,-10分层 ,error:['',''],
            effectnum:xx, // 校验一下对不对。
            changeids {'uuid':id1, 'uuid2': id2}


            {
                'op': 'update',
                'table':'客户'
                'cols': [{'col1':'value1', 'cold2':'value2', 'c3':'value3'....}],
                'oldcols':[{'col1':'value1', 'cold2':'value2', 'c3':'value3'....}],
                'id': 'xxx',
                'uuid' 'xxxx',
                'subs' : {rows;递归}
            },   -- 返回  { state: 'ok' / 'fail' , error: '' , effectnum:xx, rows {'uuid':'xxxx', 'id': xxx, 'subs' { rows: [递归]}}      }
            {
                'op': 'delete'
                'table':'客户'
                'id': 'xxx'
                'subs':: {rows;递归}
            } , -- 返回 { state: 'ok' / 'fail' , error: '' , effectnum:xx, rows {'uuid':'xxxx', 'id': xxx, 'subs' { rows: [递归]}}      }

            ...] 注意数据是分层次的，比如
            更新主表 t_m_1, 插入子表 t_z_1, 更新t_z_2, 插入子表 t_z_2的子表t_z2_z_1进行级联更新。
             'reqtype':'update'
             'args': {
                 'rows': [
                    {
                        'op': 'update',
                        'table': 't_m_1',  # 这个我们会维护一个对应表，不暴露表名，建议直接用汉字。
                        'cols': [{'col1':'value1', 'cold2':'value2', 'c3':'value3'....}],
                        'uuid': 'xxxx',
                        'id': '0',
                        'subs': {
                            rows:
                                [{
                                    'op': insert
                                    'table':'t_z_1'
                                     'cols': [{.... }]
                                     'uuid': 'xxxx',
                                     'id':'0',
                                     'subs' ''空。
                                },
                                {
                                    'op': update
                                    'table':'t_z_2'
                                     'cols': [{.... }]
                                     'uuid': 'xxxx',
                                     'id':'0',
                                     'subs':
                                     {
                                        rows:[{ 插入t_z2_z_1,}]
                                      }
                                }
                            }]
                        }
                    },
             }
         返回：   state: 'ok' / 'fail' , error: '' , effectnum:xx,
                rows {'uuid':'xxxx', 'id': xxx,  'subs' { rows: [递归]}}


  }


子表单独select。
update和insert的时候返回id的一个字典就行 changedid｛uuid1：id， uuid2：id2｝。


