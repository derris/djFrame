-------------------------- 委托维护 ---------------
1.委托contract:
  delete:不允许删除条件
    a:  pre_fee中有此委托记录
    b:  此委托锁定 finish_flag=true
  update:禁止修改条件
    a:  pre_fee中有此委托记录禁止修改client_id
    b:  委托锁定禁止修改   finish_flag=true

2.委托动态contract_action：
  delete:   只能从最后一个动态开始删除。
  insert/update: 动态要求按照顺序增加，只有在   c_action  中的  require_flag  为false的情况下，
            可以跳过此action而插入下一个action。
=======================================================

------------------------委托应收付维护--------------
1.委托应收付费用维护：pre_fee
  insert:插入应付(fee_typ='O')费用时,处理代收代付费用。判断fee_cod在费用代码表c_fee中的pair_flag的值，
         true则自动插入相同金额的应收费用，插入前判断是否已存在此应收费用，已存在不再插入
  update:禁止修改条件
        a: 已锁定(lock_flag)或已核销(audit_id)
  delete：禁止删除条件
        a: 已核销(audit_id)
2.应收付费用锁定：
3.应收付费用解锁:已核销(audit_id)禁止解锁
==========================================================


-------------------------- 已收核销 ----------------------------
核销动作：
分别循环选中的actfee和prefee，--》 actId.pop()， preId.pop() 直到有一方金额不足，就停止pop。标记已经pop的为核销。
update act_fee set ex_over = ls_seq, audit_id=true, audit_tim=current_timestamp(0) where id = actId
update pre_fee set ex_over = ls_seq, audit_id=true, audit_tim=current_timestamp(0) where id = preId
----- 省的是谁就插入谁。actfee或prefee：
insert into pre_fee(client_id, contract_id, fee_typ, fee_cod, amount,  fee_tim, rec_nam, rec_tim, ex_from, ex_feeid, remark  )
insert into act_fee(client_id, fee_typ, amount, pay_type, fee_tim, rec_nam, rec_tim, ex_from, ex_feeid ,remark )
==================================================================

------------------------- 核销删除 ------------------------------
1.核销删除查询：
  接口参数：{
    func:'核销删除查询',
    ex_parm:{
        client_id:'',
        fee_typ:''
    }
  }
  查询：根据传入的客户+费用类型，查询出最近一次核销。act_fee和pre_fee的ex_over要相同。
        select ex_over, audit_tim from act_fee where client_id = %s and fee_typ= %s and audit_id = true order by id desc limit 1 " % (l_clientid, l_feetyp)
        得出最后的审核时间。这个时间应该是唯一的，为了确保唯一，我们还要确保ex_over是一样的。
        累加prefee的东东。
  返回：
  {
        "msg":"查询成功",
        "stateCod": "1",   #  错误 < 0 > 正确--不弹出提示框--100--中心弹出提示--200--右下弹出提示--300
        "error": ["xxx", "xx"]...        # 错误数组。
        "result": {"act":[{},{},{}], "pre":[{},{},{}]}     同时返回act_fee和pre_fee
   }
2.核销删除：
   接口参数：{
     func:'核销删除',
     ex_parm:{
        ex_over:''
     }
   }
   删除：要求ex_over参数没有后续的核销（ex_from = ex_over 的记录，ex_over是空。就可以保证。也就是说：
   选择核销号，ex-from=核销号的记录，就是他产生新记录，如果这些新记录，没有exover的号，说明没有被进一步核销，就可以保证条件。）

       恢复act_fee和pre_fee至ex_over号核销前的数据，保证数据完整性。
   返回：
   {
        "msg":"成功",
        "stateCod": "202",   #  错误 < 0 > 正确--不弹出提示框--100--中心弹出提示--200--右下弹出提示--300
        "error": ["xxx", "xx"]...        # 错误数组。
   }





